---
title: "Experimento 01 Auditor Crawler"
output:
    html_document:
    css: styles.css
theme: sandstone
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse) # 
library(broom)
library(jsonlite) # Ler dados json
library(dplyr) # 
library(here)
library(DT)
library(boot)
library(ggalt)
set.seed(12345)
library(ggplot2)
library(ggbeeswarm)
source(here::here("code/lib.R"))
library(knitr)
library(kableExtra)
theme_set(theme_bw())

```

Este relatório usa dados de avaliações transparência de fiscal de uma amostra de 30 portais de transparência do estado da Paraíba. Estes dados foram obtidos por meio da execução de processo de crawling.

A utilização dessas avaliações tem como o objetivo de verificar o desempenho de diferentes técnicas durante a varreduras dos portais de transparência. Nesta pespectiva, abordagens utilizando os algoritmos BFS, DFS, Bandit (e-greedy) foram testadas.

## Lendo os dados

```{r read}
resultados_avaliacoes_exp01 = read_avaliacoes()
resultados_avaliacoes_exp01[is.na(resultados_avaliacoes_exp01)] <- ''
resultados_avaliacoes_exp01$aproach <- replace(as.character(resultados_avaliacoes_exp01$aproach), resultados_avaliacoes_exp01$aproach == "bandit", "Epsilon-greedy")
resultados_avaliacoes_exp01$aproach <- replace(as.character(resultados_avaliacoes_exp01$aproach), resultados_avaliacoes_exp01$aproach == "bfs", "Bfs")
resultados_avaliacoes_exp01$aproach <- replace(as.character(resultados_avaliacoes_exp01$aproach), resultados_avaliacoes_exp01$aproach == "dfs", "Dfs")


gararito = read_gabaritos()
gararito[is.na(gararito)] <- ''

empresas_portais <- readr::read_csv(here::here("data/empresas_portais.csv"))
```



## Removendo avaliações que não pertecem ao experimento 01

Avaliações válidas são excuções do Auditor Crawler que possuem 61 itens pesquisados. Assim, para análise do experimento 01 foram desconsideradas avaliações que não atendem este critério. 

Além disso, as avaliações do município de Curral de Cima não foran consideradas por seu portal de transparência está atualmente fora do ar.


```{r}
resultados_avaliacoes_exp01 <- resultados_avaliacoes_exp01 %>% 
  filter(tipo_exp == 'all_itens' & (municipio != 'Curral de Cima' & municipio != 'todo'))

```


## Adicionando combinação encontrada em cada município no gabarito

```{r}
empresas_portais <- empresas_portais %>% 
    select(municipio, fornecedor)

gararito<-left_join(gararito, empresas_portais, by=c("municipio"))
```


## Juntando Avaliações e Gabaritos

```{r}
# concatena os dois csv o do gabarito e avaliações do crawler
data<-left_join(resultados_avaliacoes_exp01, gararito, by=c("municipio", "item", "criterio"))
```

## Sumarizando as avaliações

Um exemplo dos dados utilizados

```{r}

sumarise_exp01 <- data %>% 
    group_by(id, municipio, criterio, item, aproach, date) %>% 
    mutate(
           
           #verifica se a avaliação foi acertiva
           tp = (valid == TRUE 
           & valid == encontrado 
           #valida se no gabarito e na avaliação o item foi encontrado na mesma url 
           & (grepl(local_encontrado, pathSought) |
                  grepl(local_encontrado_2, pathSought))) | (valid == FALSE 
           & valid == encontrado),
           
           fn =  valid == FALSE 
           & encontrado == TRUE,
           
           fp = valid == TRUE 
           & encontrado == FALSE
          )

head(sumarise_exp01)
```

## Quantificando métricas

Calculando Recall, Precision, F1 Score e métricas relacionadas ao desempenho do Auditor Crawler.

```{r}

metricas_result_exp01 <- sumarise_exp01 %>% 
    #filter(!is.na(aproach )) %>% 
    group_by(municipio, aproach, date) %>% 
    summarise(
        total_itens = n(),
        tp_total = sum(tp), 
        fn_total = sum(fn),
        fp_total = sum(fp),
        
        #cálculo das métricas 
        recall = tp_total/(tp_total + fn_total),
        precision =  tp_total/(tp_total + fp_total),
        f1_score = (2*(recall*precision))/(recall+precision),
        
        #tempo das avaliações
        median_duration_min = median(durationMin),
        median_duration = median(duration),
        max_duration = max(duration),
        max_durationMin = max(durationMin),
        median_num_access_node = median(contNodeNumberAccess),
        max_num_access_node = max(contNodeNumberAccess),
        all_access_node = sum(contNodeNumberAccess),
        combination = last(fornecedor),
        tipo_exp = last(tipo_exp)
    )


metricas_result_exp01 <- metricas_result_exp01 %>%
  filter(total_itens == 61)

metricas_result_exp01 %>% 
    write_csv(here::here("data/resultados_sumarizado_exp01.csv"))

metricas_result_exp01 %>%
  arrange(desc(recall))

```

## Avaliações por abordagem


```{r}
metricas_result_exp01 %>%
    group_by(aproach) %>% 
    summarise(ocorrencia = n()) %>%
    ggplot(aes(y=ocorrencia, x=reorder(aproach, +(ocorrencia)))) + 
    geom_bar(stat = "identity",  fill="#5499C7") + 
    ggtitle("Número de Avaliações por Abordagem") +
    xlab("Abordagem") + 
    ylab("Número de avaliações") +
    coord_flip()
```

## Número de Avaliações por abordagem

```{r}
metricas_result_exp01 %>%
    group_by(municipio) %>%
    summarise(bfs = sum(aproach == 'Bfs'), dfs = sum(aproach == 'Dfs'), bandit = sum(aproach == 'Epsilon-greedy')) %>%
    arrange(desc(dfs)) %>%
    datatable(options = list(pageLength = 10),  rownames = FALSE, class = 'cell-border stripe')
```

## Todas as Avaliações

```{r}
metricas_result_exp01 %>%
    select(municipio, aproach, date, recall, precision, f1_score) %>%
    arrange(desc(recall)) %>% 
    datatable(options = list(pageLength = 10),  rownames = FALSE, class = 'cell-border stripe')
```

## Análise das Abordagens Utilizadas

Para análise dos resultados obtidos duranter as execuções do crawler para as distintas abordagens, foi utilizado a métrica F1 Score que representa a harmonia entre os valores de Precision e Recall. 

A escolha dessa métrica foi motivada pela necessidade do equilíbrio entre os valores obtidos para Recall e Precision, em outras palavras, da necessidade de uma avaliação de transparência que consiga identificar a maior quantidade de itens possível (Recall) e que mantenha uma alta confiabilidade nos itens identificados (Precision). Abaixo é apresentada a distribuição das avaliações entre as abordagens.


```{r}
metricas_result_exp01 %>%
  group_by(aproach)  %>%
  ggplot(aes(x = aproach, y = recall)) + 
  geom_dotplot(aes(fill = aproach),
               color='white',
               binaxis = "y", 
               binwidth = 0.012,
               stackdir = "center") +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5, alpha=0.3,aes(colour='Mediana'), ) +
  scale_linetype_manual("", values=c("median"="x")) +
  scale_fill_manual(values=c("#999999", "#f39422", "#537ec5", '#293a80')) +
  scale_colour_manual(values=c("black", "black", "#56B4E9", '#293a80')) +
  ylim(0.5, 1) +
  labs(x='Algoritmo', y="Recall", color = "")

ggsave('exp01-distribuition-recall.png')

```

```{r}
metricas_result_exp01 %>%
  group_by(aproach)  %>%
  ggplot(aes(x = aproach, y = precision)) + 
  geom_dotplot(aes(fill = aproach),
               color='white',
               binaxis = "y", 
               binwidth = 0.011,
               stackdir = "center") +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5, alpha=0.3,aes(colour='Mediana'), ) +
  scale_linetype_manual("", values=c("median"="x")) +
  scale_fill_manual(values=c("#999999", "#f39422", "#537ec5", '#293a80')) +
  scale_colour_manual(values=c("black", "black", "#56B4E9", '#293a80')) +
  ylim(0.5, 1) +
  labs(x='Algoritmo', y="Precisão", color = "")

ggsave('exp01-distribuition-precision.png')
```



Com base na visualização é possível perceber que a abordagem Bandit apresenta a maior mediana. Além disso, é possível notar que a abordagem BFS é a única que não contém outlies.

## Intervalo de Confiança da Mediana encontrada do F1 Score para cada Abordagem

Vamos criar intervalos de confiança para mediana de F1 Score para verificar se os intervalos contém a mediana da amostra entre as abordagens.

```{r}
#Calcula a media das posições escolhidas nas buscas.
set.seed(123)

precision_boot <- function (d, i) {
    dt<-d[i,]
    return(c(
          median(dt$recall)
    ))
}

create_ic.recall <- function(x) {
  x <- last(x)
  df.boot <- filter(metricas_result_exp01, aproach == x)
  
  bootstrap.aproach <- boot(
          data = df.boot, 
          statistic = precision_boot, 
          R = 4000 )
  
  ci = tidy(bootstrap.aproach, 
          conf.level = .95,
          conf.method = "bca",
          conf.int = TRUE)
  
  print(glimpse(ci))
  
  return(ci)
}


ics.aproach_exp01.recall <- metricas_result_exp01 %>%
  group_by(aproach) %>% 
   summarise(
     median_value = median(recall),
     ci = list(create_ic.recall(aproach))
  ) %>% 
  unnest(ci) 
  
ics.aproach_exp01.recall %>%  
  ggplot() + 
  geom_errorbar(aes(x = aproach, y = statistic, ymin = conf.low, ymax = conf.high), width = 0.05) +
  geom_point(aes(x=aproach, y=median_value), color='#f39422', size=2) + 
  ylim(0.7, 1)

```



De acordo com a visulização é verificar com 95% de confiança que a mediana da amostra para cada abordagem está contida nos intervalos.


```{r}
#Calcula a media das posições escolhidas nas buscas.
set.seed(123)

precision_boot <- function (d, i) {
    dt<-d[i,]
    return(c(
          median(dt$precision)
    ))
}

create_ic.precision <- function(x) {
  x <- last(x)
  df.boot <- filter(metricas_result_exp01, aproach == x)
  
  bootstrap.aproach.precision <- boot(
          data = df.boot, 
          statistic = precision_boot, 
          R = 4000 )
  
  ci = tidy(bootstrap.aproach.precision, 
          conf.level = .95,
          conf.method = "bca",
          conf.int = TRUE)
  
  print(glimpse(ci))
  
  return(ci)
}


ics.aproach_exp01.precision <- metricas_result_exp01 %>%
  group_by(aproach) %>% 
   summarise(
     median_value = median(precision),
     ci = list(create_ic.precision(aproach))
  ) %>% 
  unnest(ci) 
  
ics.aproach_exp01.precision %>%  
  ggplot() + 
  geom_errorbar(aes(x = aproach, y = statistic, ymin = conf.low, ymax = conf.high), width = 0.05) +
  geom_point(aes(x=aproach, y=median_value), color='#f39422', size=1) + 
  ylim(0.7, 1)

```


## F1 Score por cada Município da Amostra 


```{r}
metricas_result_exp01 %>% 
  group_by(municipio, aproach) %>% 
  summarise(max_value = max(f1_score), min_value = min(f1_score), median_value=median(f1_score)) %>% 
  ggplot(aes(y=municipio)) + 
  geom_point(aes(x=min_value, color='#293a80'), size=1, shape=108) +
  geom_point(aes(x= max_value, color='#537ec5'), size=1, shape=108)  +
  geom_dumbbell(color="#e3e2e1", aes(x = min_value, xend = max_value), colour_x = "#293a80", colour_xend = "#537ec5", size=3.1,
                dot_guide=TRUE, dot_guide_size=0.25, shape=108) + 
  #geom_point(aes(x= median_value, color='#f39422'), size=6, shape=108) +
  geom_point(aes(x= median_value, color='#f39422'), size=3, alpha= 0.8, shape=108) +
  scale_color_manual(name = "", values = c("#293a80", "#537ec5", "#f39422"), labels = c("Mínimo", "Máximo", "Mediana")) +
  labs(x='F1 Score', y=NULL, title="F1 Score Por Município") +
  facet_grid(.~ aproach)
```


```{r eval=FALSE, include=FALSE}

#Calcula a media das posições escolhidas nas buscas.
set.seed(123)

f1_score_boot <- function (d, i) {
    dt<-d[i,]
    return(c(
          median(dt$f1_score)
    ))
}

create_ic.mun <- function(x, y) {
  x <- last(x)
  y <- last(y)
  
  df.boot.mun <- filter(metricas_result_exp01, aproach == x, municipio == y)
  
  bootstrap.aproach.mun <- boot(
          data = df.boot.mun, 
          statistic = f1_score_boot, 
          R = 4000 )
  
  print(glimpse(bootstrap.aproach.mun))

  
  ci = tidy(bootstrap.aproach.mun, 
          conf.level = .95,
          conf.method = "bca",
          conf.int = TRUE)
  
  print(glimpse(ci))
  
  return(ci)
}


boot.aproach_exp01.mun <- metricas_result_exp01 %>%
  group_by(aproach, municipio) %>% 
  summarise(
     median_value = median(f1_score),
     ci = create_ic.mun(aproach, municipio)
  ) %>% 
  unnest(ci)

  
boot.aproach_exp01.mun %>% 
  ggplot() + 
  geom_errorbar(aes(x = municipio, y = statistic, ymin = conf.low, ymax = conf.high), width = 0.05) +
  geom_point(aes(x=municipio, y=median_value), color='red', size=1) +
  coord_flip() +
  facet_grid(. ~aproach) 
  

```




## Tempo de Duração  

```{r}
metricas_result_exp01 %>%
    ggplot(aes(x = reorder(aproach, +(max_durationMin)), y = max_durationMin)) +
    geom_boxplot() 

```

## Nós Acessados  


```{r}

metricas_result_exp01 %>%
  ggplot(aes(x = reorder(aproach, +(max_num_access_node)), y = max_num_access_node)) +
  geom_boxplot()
```


## f1 Score por combinação

```{r}

metricas_result_exp01 %>% 
  group_by(combination) %>% 
  summarise(max_value = max(f1_score), min_value = min(f1_score), median_value=median(f1_score)) %>% 
  ggplot(aes(y=combination)) + 
  geom_point(aes(x=min_value, color='#293a80'), size=3) +
  geom_point(aes(x= max_value, color='#537ec5'), size=3)  +
  geom_dumbbell(color="#e3e2e1", aes(x = min_value, xend = max_value), colour_x = "#293a80", colour_xend = "#537ec5", size=3,
                dot_guide=TRUE, dot_guide_size=0.25) + 
  geom_point(aes(x= median_value, color='#f39422'), size=3, alpha=0.7) +
  scale_color_manual(name = "", values = c("#293a80", "#537ec5", "#f39422"), labels = c("Mínimo", "Máximo", "Mediana")) +
  labs(x='F1 Score', y=NULL, title="Combinações por F1 Score") 

```

## Número de nós acessados por combinação

```{r}
metricas_result_exp01 %>% 
  group_by(combination) %>% 
  summarise(max_value = max(max_num_access_node), min_value = min(max_num_access_node), median_value=median(max_num_access_node)) %>% 
  ggplot(aes(y=combination)) + 
  geom_point(aes(x=min_value, color='#293a80'), size=3) +
  geom_point(aes(x= max_value, color='#537ec5'), size=3)  +
  geom_dumbbell(color="#e3e2e1", aes(x = min_value, xend = max_value), colour_x = "#293a80", colour_xend = "#537ec5", size=3,
                dot_guide=TRUE, dot_guide_size=0.25) + 
  geom_point(aes(x= median_value, color='#f39422'), size=3, alpha=0.7) +
  scale_color_manual(name = "", values = c("#293a80", "#537ec5", "#f39422"), labels = c("Mínimo", "Máximo", "Mediana")) +
  labs(x='Número de nós', y=NULL, title="Combinações Por Número de Nós Acessados") 
```

## Duração das avaliações por combinações

```{r}
metricas_result_exp01 %>% 
  group_by(combination) %>% 
  summarise(max_value = max(max_durationMin), min_value = min(max_durationMin), median_value=median(max_durationMin)) %>% 
  ggplot(aes(y=combination)) + 
  geom_point(aes(x=min_value, color='#293a80'), size=3) +
  geom_point(aes(x= max_value, color='#537ec5'), size=3)  +
  geom_dumbbell(color="#e3e2e1", aes(x = min_value, xend = max_value), colour_x = "#293a80", colour_xend = "#537ec5", size=3,
                dot_guide=TRUE, dot_guide_size=0.25) + 
  geom_point(aes(x= median_value, color='#f39422'), size=3, alpha=0.7) +
  scale_color_manual(name = "", values = c("#293a80", "#537ec5", "#f39422"), labels = c("Mínimo", "Máximo", "Mediana")) +
  labs(x='Minutos', y=NULL, title="Combinações Por Tempo de Duração") 
```


